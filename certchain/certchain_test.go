package certchain_test

import (
	"context"
	"math/rand"
	"testing"
	"time"

	"github.com/filecoin-project/go-f3/certchain"
	"github.com/filecoin-project/go-f3/certs"
	"github.com/filecoin-project/go-f3/gpbft"
	"github.com/filecoin-project/go-f3/internal/clock"
	"github.com/filecoin-project/go-f3/internal/consensus"
	"github.com/filecoin-project/go-f3/manifest"
	"github.com/filecoin-project/go-f3/sim/signing"
	"github.com/stretchr/testify/require"
)

func TestCertChain_GenerateAndVerify(t *testing.T) {
	const (
		seed            = 1427
		certChainLength = 150
	)

	ctx, clk := clock.WithMockClock(context.Background())
	m := manifest.LocalDevnetManifest()
	signVerifier := signing.NewFakeBackend()
	rng := rand.New(rand.NewSource(seed * 23))
	generatePublicKey := func(id gpbft.ActorID) gpbft.PubKey {
		//TODO: add the ability to evolve public key across instances. Fake signing
		//      backed does not support this.

		// Use allow instead of GenerateKey for a reproducible key generation.
		return signVerifier.Allow(int(id))
	}
	initialPowerTable := generatePowerTable(t, rng, generatePublicKey, nil)

	ec := consensus.NewFakeEC(ctx,
		consensus.WithSeed(seed*13),
		consensus.WithBootstrapEpoch(m.BootstrapEpoch),
		consensus.WithECPeriod(m.EC.Period),
		consensus.WithInitialPowerTable(initialPowerTable),
		consensus.WithEvolvingPowerTable(
			func(epoch int64, entries gpbft.PowerEntries) gpbft.PowerEntries {
				if epoch == m.BootstrapEpoch-m.EC.Finality {
					return initialPowerTable
				}
				rng := rand.New(rand.NewSource(epoch * seed))
				next := generatePowerTable(t, rng, generatePublicKey, entries)
				return next
			},
		),
	)

	subject, err := certchain.New(
		certchain.WithSeed(seed),
		certchain.WithSignVerifier(signVerifier),
		certchain.WithManifest(m),
		certchain.WithEC(ec),
	)
	require.NoError(t, err)

	// The mock clock is buried into context passed to fake EC. The face EC will
	// refuse to generate a chain if the clock is not advanced. Advance it
	// sufficiently to never be bothered by it again.
	//
	// The fake EC and its relationship with clock needs to be reworked: Clock should
	// ideally be passed as an option, and its absence should mean "advance the clock
	// as needed". Because, we do not always care about controlling the progress of
	// chain generated by fake EC.
	clk.Add(200 * time.Hour)

	generatedChain, err := subject.Generate(ctx, certChainLength)
	require.NoError(t, err)

	initialCommittee, err := subject.GetCommittee(ctx, m.InitialInstance)
	require.NoError(t, err)

	nextInstance, _, _, err := certs.ValidateFinalityCertificates(
		signVerifier,
		m.NetworkName,
		initialCommittee.PowerTable.Entries,
		generatedChain[0].GPBFTInstance,
		generatedChain[0].ECChain.Base(),
		generatedChain...)
	require.NoError(t, err)
	require.Equal(t, m.InitialInstance+certChainLength, nextInstance)
	require.NoError(t, subject.Validate(ctx, generatedChain))

	// Test verification without generation on a fresh CertChain instance is
	// consistent for the same EC.
	subject2, err := certchain.New(
		certchain.WithSeed(seed),
		certchain.WithSignVerifier(signVerifier),
		certchain.WithManifest(m),
		certchain.WithEC(ec),
	)
	require.NoError(t, err)
	require.NoError(t, subject2.Validate(ctx, generatedChain))
}

func generatePowerTable(t *testing.T, rng *rand.Rand, generatePublicKey func(id gpbft.ActorID) gpbft.PubKey, previousEntries gpbft.PowerEntries) gpbft.PowerEntries {
	const (
		maxEntries             = 100
		maxPower               = 1 << 20
		minPower               = 0 // Pick a sufficiently low power to facilitate entries with zero scaled power.
		actorIDOffset          = 1413
		powerChangeProbability = 0.2
	)

	size := rng.Intn(maxEntries)
	entries := make(gpbft.PowerEntries, 0, size)
	for i := range size {
		var entry gpbft.PowerEntry
		if i < previousEntries.Len() {
			entry = previousEntries[i]
			changedPower := rng.Float64() > powerChangeProbability
			if changedPower {
				entry.Power = gpbft.NewStoragePower(int64(rng.Intn(maxPower) + minPower))
			}
		} else {
			id := gpbft.ActorID(uint64(actorIDOffset + i))
			entry = gpbft.PowerEntry{
				ID:     id,
				Power:  gpbft.NewStoragePower(int64(rng.Intn(maxPower) + minPower)),
				PubKey: generatePublicKey(id),
			}
		}
		entries = append(entries, entry)
	}
	next := gpbft.NewPowerTable()
	require.NoError(t, next.Add(entries...))
	return next.Entries
}
