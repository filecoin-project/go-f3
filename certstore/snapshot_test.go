package certstore

import (
	"bytes"
	"context"
	"math/rand"
	"testing"
	"time"

	"github.com/filecoin-project/go-f3/certchain"
	"github.com/filecoin-project/go-f3/certs"
	"github.com/filecoin-project/go-f3/gpbft"
	"github.com/filecoin-project/go-f3/internal/clock"
	"github.com/filecoin-project/go-f3/internal/consensus"
	"github.com/filecoin-project/go-f3/manifest"
	"github.com/filecoin-project/go-f3/sim/signing"
	"github.com/ipfs/go-cid"
	"github.com/ipfs/go-datastore"
	"github.com/multiformats/go-multihash"
	"github.com/stretchr/testify/require"
	"go.uber.org/zap/buffer"
	"golang.org/x/crypto/blake2b"
)

func Test_SnapshotExportImportRoundTrip(t *testing.T) {
	const (
		seed                      = 1427
		certChainLength           = 150
		testingPowerTableFreqency = uint64(23)
	)

	ctx, clk := clock.WithMockClock(context.Background())
	m := manifest.LocalDevnetManifest()
	m.InitialInstance = 100
	signVerifier := signing.NewFakeBackend()
	rng := rand.New(rand.NewSource(seed * 23))
	generatePublicKey := func(id gpbft.ActorID) gpbft.PubKey {
		//TODO: add the ability to evolve public key across instances. Fake signing
		//      backed does not support this.

		// Use allow instead of GenerateKey for a reproducible key generation.
		return signVerifier.Allow(int(id))
	}
	initialPowerTable := generatePowerTable(t, rng, generatePublicKey, nil)
	ptCid, err := certs.MakePowerTableCID(initialPowerTable)
	require.NoError(t, err)
	m.InitialPowerTable = ptCid

	ec := consensus.NewFakeEC(
		consensus.WithClock(clk),
		consensus.WithSeed(seed*13),
		consensus.WithBootstrapEpoch(m.BootstrapEpoch),
		consensus.WithECPeriod(m.EC.Period),
		consensus.WithInitialPowerTable(initialPowerTable),
		consensus.WithEvolvingPowerTable(
			func(epoch int64, entries gpbft.PowerEntries) gpbft.PowerEntries {
				if epoch == m.BootstrapEpoch-m.EC.Finality {
					return initialPowerTable
				}
				rng := rand.New(rand.NewSource(epoch * seed))
				next := generatePowerTable(t, rng, generatePublicKey, entries)
				return next
			},
		),
	)

	subject, err := certchain.New(
		certchain.WithSeed(seed),
		certchain.WithSignVerifier(signVerifier),
		certchain.WithManifest(m),
		certchain.WithEC(ec),
	)
	require.NoError(t, err)

	// The mock clock is buried into context passed to fake EC. The face EC will
	// refuse to generate a chain if the clock is not advanced. Advance it
	// sufficiently to never be bothered by it again.
	//
	// The fake EC and its relationship with clock needs to be reworked: Clock should
	// ideally be passed as an option, and its absence should mean "advance the clock
	// as needed". Because, we do not always care about controlling the progress of
	// chain generated by fake EC.
	clk.Add(200 * time.Hour)

	generatedChain, err := subject.Generate(ctx, certChainLength)
	require.NoError(t, err)
	m.BootstrapEpoch = generatedChain[0].ECChain.Base().Epoch

	ds1 := datastore.NewMapDatastore()
	cs, err := OpenOrCreateStore(ctx, ds1, generatedChain[0].GPBFTInstance, initialPowerTable)
	cs.powerTableFrequency = testingPowerTableFreqency
	require.NoError(t, err)

	for _, cert := range generatedChain {
		cs.Put(ctx, cert)
	}

	snapshot := buffer.Buffer{}
	c, _, err := cs.ExportLatestSnapshot(ctx, &snapshot)
	require.NoError(t, err)
	require.NotEqual(t, c, cid.Undef)
	require.Equal(t, int(c.Prefix().Version), 1)
	require.Equal(t, int(c.Prefix().Codec), cid.Raw)
	require.Equal(t, int(c.Prefix().MhType), 0xb220)
	hash := blake2b.Sum256(snapshot.Bytes())
	mh, err := multihash.Encode(hash[:], multihash.BLAKE2B_MIN+31)
	require.NoError(t, err)
	require.Equal(t, c.Hash(), multihash.Multihash(mh))

	ds2 := datastore.NewMapDatastore()
	err = importSnapshotToDatastoreWithTestingPowerTableFrequency(ctx, bytes.NewReader(snapshot.Bytes()), ds2, &m, testingPowerTableFreqency)
	require.NoError(t, err)

	require.Equal(t, ds1, ds2)

	ds3 := datastore.NewMapDatastore()
	err = ImportSnapshotToDatastore(ctx, bytes.NewReader(snapshot.Bytes()), ds3, &m)
	require.NoError(t, err)

	require.NotEqual(t, ds1, ds3)

	// Test manifest validation logic
	ds4 := datastore.NewMapDatastore()
	m2 := manifest.LocalDevnetManifest()

	// bad bootstrap epoch
	m2.InitialInstance = m.InitialInstance
	m2.BootstrapEpoch = m.BootstrapEpoch + 1
	err = ImportSnapshotToDatastore(ctx, bytes.NewReader(snapshot.Bytes()), ds4, &m2)
	require.ErrorContains(t, err, "bootstrap epoch")

	// bad initial instance
	m2.BootstrapEpoch = m.BootstrapEpoch
	m2.InitialInstance = m.InitialInstance + 1
	err = ImportSnapshotToDatastore(ctx, bytes.NewReader(snapshot.Bytes()), ds4, &m2)
	require.ErrorContains(t, err, "initial instance")

	// bad InitialPowerTable
	m2.InitialInstance = m.InitialInstance
	m2.InitialPowerTable = generatedChain[1].ECChain.Head().PowerTable
	err = ImportSnapshotToDatastore(ctx, bytes.NewReader(snapshot.Bytes()), ds4, &m2)
	require.ErrorContains(t, err, "initial power table CID")
}

func generatePowerTable(t *testing.T, rng *rand.Rand, generatePublicKey func(id gpbft.ActorID) gpbft.PubKey, previousEntries gpbft.PowerEntries) gpbft.PowerEntries {
	const (
		maxEntries             = 100
		maxPower               = 1 << 20
		minPower               = 0 // Pick a sufficiently low power to facilitate entries with zero scaled power.
		actorIDOffset          = 1413
		powerChangeProbability = 0.2
	)

	size := rng.Intn(maxEntries)
	entries := make(gpbft.PowerEntries, 0, size)
	for i := range size {
		var entry gpbft.PowerEntry
		if i < previousEntries.Len() {
			entry = previousEntries[i]
			changedPower := rng.Float64() > powerChangeProbability
			if changedPower {
				entry.Power = gpbft.NewStoragePower(int64(rng.Intn(maxPower) + minPower))
			}
		} else {
			id := gpbft.ActorID(uint64(actorIDOffset + i))
			entry = gpbft.PowerEntry{
				ID:     id,
				Power:  gpbft.NewStoragePower(int64(rng.Intn(maxPower) + minPower)),
				PubKey: generatePublicKey(id),
			}
		}
		entries = append(entries, entry)
	}
	next := gpbft.NewPowerTable()
	require.NoError(t, next.Add(entries...))
	return next.Entries
}
